<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>appsapp-module</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	    <link rel="stylesheet" href="../styles/style.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">appsapp-module</a>
            <button type="button" class="btn btn-default btn-menu fa fa-bars" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
            <div id="book-search-input" role="search">
                <input type="text" placeholder="Type to search">
            </div>
            <nav>
            
                <ul class="list">
            
                    <li class="title">
                        <a href="../index.html">appsapp-module</a>
                    </li>
            
                    <li class="divider"></li>
            
            
                    <li class="chapter">
                        <a data-type="chapter-link" href="../index.html"><span class="fa fa-home"></span>Getting started</a>
                        <ul class="links">
                                <li class="link">
                                    <a 
                                        
                                         href="../overview.html" 
                                         href="../overview.html" 
                                        >
                                        <span class="fa fa-th"></span>Overview
                                    </a>
                                </li>
                                <li class="link">
                                  <a href="../index.html" ><span class="fa fa-file-text-o"></span>README</a>
                                </li>
                        </ul>
                    </li>
            
            
            
            
            
                    <li class="chapter">
                        <div class="simple menu-toggler" data-toggle="collapse"
                                data-target="#xs-classes-links"
                            >
                            <span class="fa fa-file-code-o"></span>
                            <span>Classes</span>
                            <span class="fa fa-angle-down"></span>
                        </div>
                        <ul class="links collapse "
                                id="xs-classes-links"
                            >
                                <li class="link">
                                    <a href="../classes/PersistableModel.html" >PersistableModel</a>
                                </li>
                        </ul>
                    </li>
            
            
            
                    <li class="chapter">
                        <div class="simple menu-toggler" data-toggle="collapse"
                                data-target="#xs-interfaces-links"
                            >
                            <span class="fa fa-info"></span>
                            <span>Interfaces</span>
                            <span class="fa fa-angle-down"></span>
                        </div>
                        <ul class="links collapse "
                                id="xs-interfaces-links"
                            >
                                <li class="link">
                                    <a href="../interfaces/AppsappModuleProviderMessages.html" >AppsappModuleProviderMessages</a>
                                </li>
                                <li class="link">
                                    <a href="../interfaces/actionCustom.html" >actionCustom</a>
                                </li>
                                <li class="link">
                                    <a href="../interfaces/actionEmail.html" >actionEmail</a>
                                </li>
                                <li class="link">
                                    <a href="../interfaces/actionGoogleSheets.html" >actionGoogleSheets</a>
                                </li>
                                <li class="link">
                                    <a href="../interfaces/actionWebhook.html"  data-type="entity-link" class="active" >actionWebhook</a>
                                </li>
                                <li class="link">
                                    <a href="../interfaces/appRequest.html" >appRequest</a>
                                </li>
                        </ul>
                    </li>
            
            
                    <li class="chapter">
                        <div class="simple menu-toggler" data-toggle="collapse"
                                data-target="#xs-miscellaneous-links"
                            >
                            <span class="fa fa-cubes"></span>
                            <span>Miscellaneous</span>
                            <span class="fa fa-angle-down"></span>
                        </div>
                        <ul class="links collapse "
                                id="xs-miscellaneous-links"
                            >
                                <li class="link">
                                  <a href="../miscellaneous/functions.html" data-type="entity-link" >Functions</a>
                                </li>
                                <li class="link">
                                  <a href="../miscellaneous/variables.html" data-type="entity-link" >Variables</a>
                                </li>
                        </ul>
                    </li>
            
            
                    <li class="chapter">
                        <a data-type="chapter-link" href="../coverage.html" ><span class="fa fa-tasks"></span>Documentation coverage</a>
                    </li>
            
            
                </ul>
            
            </nav>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <nav>
                   
                       <ul class="list">
                   
                           <li class="title">
                               <a href="../index.html">appsapp-module</a>
                           </li>
                   
                           <li class="divider"></li>
                   
                               <div id="book-search-input" role="search">
                                   <input type="text" placeholder="Type to search">
                               </div>
                   
                           <li class="chapter">
                               <a data-type="chapter-link" href="../index.html"><span class="fa fa-home"></span>Getting started</a>
                               <ul class="links">
                                       <li class="link">
                                           <a 
                                               
                                                href="../overview.html" 
                                                href="../overview.html" 
                                               >
                                               <span class="fa fa-th"></span>Overview
                                           </a>
                                       </li>
                                       <li class="link">
                                         <a href="../index.html" ><span class="fa fa-file-text-o"></span>README</a>
                                       </li>
                               </ul>
                           </li>
                   
                   
                   
                   
                   
                           <li class="chapter">
                               <div class="simple menu-toggler" data-toggle="collapse"
                                       data-target="#classes-links"
                   >
                                   <span class="fa fa-file-code-o"></span>
                                   <span>Classes</span>
                                   <span class="fa fa-angle-down"></span>
                               </div>
                               <ul class="links collapse "
                                       id="classes-links"
                   >
                                       <li class="link">
                                           <a href="../classes/PersistableModel.html" >PersistableModel</a>
                                       </li>
                               </ul>
                           </li>
                   
                   
                   
                           <li class="chapter">
                               <div class="simple menu-toggler" data-toggle="collapse"
                                       data-target="#interfaces-links"
                   >
                                   <span class="fa fa-info"></span>
                                   <span>Interfaces</span>
                                   <span class="fa fa-angle-down"></span>
                               </div>
                               <ul class="links collapse "
                                       id="interfaces-links"
                   >
                                       <li class="link">
                                           <a href="../interfaces/AppsappModuleProviderMessages.html" >AppsappModuleProviderMessages</a>
                                       </li>
                                       <li class="link">
                                           <a href="../interfaces/actionCustom.html" >actionCustom</a>
                                       </li>
                                       <li class="link">
                                           <a href="../interfaces/actionEmail.html" >actionEmail</a>
                                       </li>
                                       <li class="link">
                                           <a href="../interfaces/actionGoogleSheets.html" >actionGoogleSheets</a>
                                       </li>
                                       <li class="link">
                                           <a href="../interfaces/actionWebhook.html"  data-type="entity-link" class="active" >actionWebhook</a>
                                       </li>
                                       <li class="link">
                                           <a href="../interfaces/appRequest.html" >appRequest</a>
                                       </li>
                               </ul>
                           </li>
                   
                   
                           <li class="chapter">
                               <div class="simple menu-toggler" data-toggle="collapse"
                                       data-target="#miscellaneous-links"
                   >
                                   <span class="fa fa-cubes"></span>
                                   <span>Miscellaneous</span>
                                   <span class="fa fa-angle-down"></span>
                               </div>
                               <ul class="links collapse "
                                       id="miscellaneous-links"
                   >
                                       <li class="link">
                                         <a href="../miscellaneous/functions.html" data-type="entity-link" >Functions</a>
                                       </li>
                                       <li class="link">
                                         <a href="../miscellaneous/variables.html" data-type="entity-link" >Variables</a>
                                       </li>
                               </ul>
                           </li>
                   
                   
                           <li class="chapter">
                               <a data-type="chapter-link" href="../coverage.html" ><span class="fa fa-tasks"></span>Documentation coverage</a>
                           </li>
                   
                   
                       </ul>
                   
                   </nav>
               </div>
               <div class="content interface">
                   <div class="content-data">










<ol class="breadcrumb">
  <li>Interfaces</li>
  <li>actionWebhook</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
    <li class="active">
        <a href="#info" id="info-tab" role="tab" data-toggle="tab" data-link="info">Info</a>
    </li>


    <li>
        <a href="#source" role="tab" id="source-tab" data-toggle="tab" data-link="source">Source</a>
    </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="c-info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>src/module/models/persistable.ts</code>
        </p>



        <section>
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                        <a href="#additionalActions">additionalActions</a>
                                </li>
                                <li>
                                        <a href="#data">data</a>
                                </li>
                                <li>
                                        <a href="#name">name</a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section>
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="additionalActions"></a>
                                        <span class="name"><b>additionalActions</b><a href="#additionalActions"><span class="fa fa-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>additionalActions:     <code></code>
</code>
                                    </td>
                                </tr>





                                    <tr>
                                        <td class="col-md-4">
                                            <div class="io-line">Defined in <a href="" data-line="44" class="link-to-prism">src/module/models/persistable.ts:44</a></div>
                                        </td>
                                    </tr>

                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="data"></a>
                                        <span class="name"><b>data</b><a href="#data"><span class="fa fa-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>data:     <code>literal type</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>literal type</code>

                                        </td>
                                    </tr>



                                    <tr>
                                        <td class="col-md-4">
                                            <div class="io-line">Defined in <a href="" data-line="39" class="link-to-prism">src/module/models/persistable.ts:39</a></div>
                                        </td>
                                    </tr>

                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="name"></a>
                                        <span class="name"><b>name</b><a href="#name"><span class="fa fa-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>name:     <code></code>
</code>
                                    </td>
                                </tr>





                                    <tr>
                                        <td class="col-md-4">
                                            <div class="io-line">Defined in <a href="" data-line="38" class="link-to-prism">src/module/models/persistable.ts:38</a></div>
                                        </td>
                                    </tr>

                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade tab-source-code" id="c-source">
        <pre class="line-numbers"><code class="language-typescript">import {AngularFireDatabase, AngularFireObject, DatabaseQuery} from &quot;angularfire2/database&quot;;
import {validate, validateSync} from &quot;class-validator&quot;;
import {plainToClass, serialize} from &quot;class-transformer&quot;;
import {AngularFireAuth} from &quot;angularfire2/auth&quot;;
import {getFromContainer} from &quot;class-validator&quot;;
import {MetadataStorage} from &quot;class-validator&quot;;
import {UUID} from &quot;angular2-uuid&quot;;
import {AppsappModuleProviderMessages} from &quot;../interfaces/messages&quot;;
import {HttpClient} from &quot;@angular/common/http&quot;;
import * as objectHash from &#x27;object-hash&#x27;;
import {Observable, Observer} from &#x27;rxjs&#x27;;


declare var global: any;

export interface actionEmail {
    name: &#x27;email&#x27;,
    data: {
        template?: string,
        to: string,
        from?: string,
        subject?: string
    },
    additionalActions?: [actionEmail | actionWebhook | actionGoogleSheets | actionCustom]
}

export interface actionGoogleSheets {
    name: &#x27;googleSheets&#x27;,
    data?: {
        to: string,
        from?: string,
        subject?: string
    },
    additionalActions?: [actionEmail | actionWebhook | actionGoogleSheets | actionCustom]
}

export interface actionWebhook {
    name: &#x27;webhook&#x27;,
    data: {
        url: string,
        method: &#x27;get&#x27; | &#x27;post&#x27; | &#x27;head&#x27; | &#x27;put&#x27; | &#x27;patch&#x27; | &#x27;delete&#x27;,
        type: &#x27;json&#x27; | &#x27;html&#x27; | &#x27;xml&#x27;
    },
    additionalActions?: [actionEmail | actionWebhook | actionGoogleSheets | actionCustom]
}

export interface actionCustom {
    name: &#x27;custom&#x27;,
    data?: {
        name: string
    },
    additionalActions?: [actionEmail | actionWebhook | actionGoogleSheets | actionCustom]
}


export class PersistableModel {

    private __httpClient: HttpClient;
    private __isLoadedPromise: Promise&lt;any&gt;;
    private __isLoaded: boolean &#x3D; false;
    private __isAutosave: boolean &#x3D; false;
    private __observer: Observer&lt;any&gt;;
    private __observable: Observable&lt;any&gt;;
    private __uuid: string &#x3D; &#x27;&#x27;;
    private __firebaseDatabase: AngularFireDatabase;
    private __firebaseDatabasePath: string;
    private __firebaseDatabaseRoot: string &#x3D; &#x27;session&#x27;;
    private __angularFireObject: AngularFireObject&lt;any&gt;;
    private __bindings &#x3D; {};
    private __bindingsObserver &#x3D; {};
    private __validator &#x3D; {};
    private __validatorObserver &#x3D; {};
    private __edited &#x3D; {};
    private __editedObserver: Observer&lt;any&gt;;
    private __editedObservable: Observable&lt;any&gt;;
    private __editedObservableCallbacks: any &#x3D; [];
    private __editedObservableObservers: any &#x3D; [];
    private __temp &#x3D; {};
    private __forceUpdateProperty &#x3D; {};
    private __persistenceManager: any;
    private __isOnline: boolean &#x3D; true;
    private __validationErrors: any &#x3D; {};
    private __metadata &#x3D; [];
    private _hasPendingChanges: boolean &#x3D; false;
    private __conditionBindings: any &#x3D; {};
    private __conditionActionIfMatches: any &#x3D; {};
    private __conditionActionIfMatchesAction: any &#x3D; {};
    private __conditionActionIfMatchesObserver: any &#x3D; {};
    private __conditionActionIfMatchesRemovedProperties: any &#x3D; {};
    private __conditionContraintsProperties: any &#x3D; {};
    private __conditionContraintsPropertiesValue: any &#x3D; {};
    private __conditionContraintsAffectedProperties: any &#x3D; {};
    private __messages: AppsappModuleProviderMessages;
    private __appsAppModuleProvider: any;
    private __notificationProvider: any;
    private __parent: any;
    private __hashedValues: object &#x3D; {};

    /**
     * PersistanceManager as an optional argument when changes were persisted to stable database
     */
    constructor() {

        this.__metadata &#x3D; getFromContainer(MetadataStorage).getTargetValidationMetadatas(this.constructor, &#x27;&#x27;);

        // check if all loaded metadata has corresponding properties
        this.__metadata.forEach((metadata) &#x3D;&gt; {

            if (this[metadata.propertyName] &#x3D;&#x3D; undefined) {
                this[metadata.propertyName] &#x3D; null;
            }
        });


        this.__init();

    }

    /**
     *
     * @private
     */
    private __init() {


        let self &#x3D; this;


        /**
         * create observerable and observer for handling the models data changes
         */
        this.__editedObservable &#x3D; new Observable&lt;any&gt;((observer: Observer&lt;any&gt;) &#x3D;&gt; {
            self.__editedObserver &#x3D; observer;
        });

        /**
         * create observerable and observer for handling the models data changes
         */
        this.__observable &#x3D; new Observable&lt;any&gt;((observer: Observer&lt;any&gt;) &#x3D;&gt; {
            self.__observer &#x3D; observer;
            self.__observer.next(this);
        });


        /**
         * creates and update bindings for getProperty()-Method
         */
        this.__observable.subscribe((next) &#x3D;&gt; {

            if (!self.hasPendingChanges() || self.getFirebaseDatabase() &#x3D;&#x3D;&#x3D; undefined) {

                if (self.__bindingsObserver) {

                    self.__editedObservableObservers.forEach((callback: any) &#x3D;&gt; {
                        if (next[callback.property] !&#x3D;&#x3D; undefined &amp;&amp; callback.first &#x3D;&#x3D;&#x3D; undefined) {
                            callback.callback(next[callback.property]);
                            callback.first &#x3D; true;
                        }
                    });

                    Object.keys(self.__bindingsObserver).forEach((property) &#x3D;&gt; {
                        if (!self.hasChanges(property) || self.__forceUpdateProperty[property] !&#x3D;&#x3D; undefined) {
                            if (next[property] !&#x3D;&#x3D; undefined) {
                                self.executeConditionValidatorCircular(property);
                                self.__bindingsObserver[property].next(next[property]);
                            }
                        }

                    });

                }


            }


        });


    }

    /**
     * get http client
     * @returns HttpClient
     */
    public getHttpClient() {
        return this.__httpClient;
    }

    /**
     * set http client
     * @param HttpClient http
     * @returns {PersistableModel}
     */
    private setHttpClient(http) {

        this.__httpClient &#x3D; http;
        return this;

    }

    /**
     * update property
     * @param property
     * @param value
     */
    public update(property, value) {

        let observer &#x3D; this.setProperty(property, value).setHasNoChanges(property).getPropertyObserver(property);
        if (observer) {
            observer.next(value);
        }


        try {
            delete this.__bindings[property];
        } catch (e) {
            // e
        }


        return this;

    }

    /**
     * call next method on observer
     * @returns {PersistableModel}
     */
    public emit() {
        if (this.__observer) {
            this.__observer.next(this);
        }
        return this;
    }


    /**
     * save with optional observable
     * @param action
     * @returns {Promise&lt;any&gt;}
     */
    public saveWithPromise(action?: actionEmail | actionWebhook | actionGoogleSheets | actionCustom | string) {

        let self &#x3D; this;

        return new Promise(function (resolve, reject) {

            self.save(action).subscribe((next) &#x3D;&gt; {

            }, (error) &#x3D;&gt; {

                reject(error);

            }, () &#x3D;&gt; {

                resolve();

            })


        });

    }


    /**
     * execute cation
     * @param action
     * @returns {Promise&lt;any&gt;}
     */
    public action(action: { name: string, data?: {} }) {

        let self &#x3D; this;

        let observable &#x3D; new Observable&lt;any&gt;((observer: Observer&lt;any&gt;) &#x3D;&gt; {

            if (self.__persistenceManager) {
                self.__persistenceManager.action(self, observer, action).then((success) &#x3D;&gt; {
                    observer.complete();
                }).catch((error) &#x3D;&gt; {
                    observer.error(error);
                });
            } else {
                observer.error(&#x27;No persistence Manger provided&#x27;);
            }

        });


        return new Promise(function (resolve, reject) {

            observable.subscribe((next) &#x3D;&gt; {
            }, (error) &#x3D;&gt; {
                reject(error);
            }, () &#x3D;&gt; {
                resolve();
            })

        });


    }


    /**
     * trigger custom action
     * @param string action
     * @param boolean silent
     * @returns {Observable&lt;any&gt;}
     */
    public trigger(action: string) {

        var self &#x3D; this;

        return new Observable&lt;any&gt;((observer: Observer&lt;any&gt;) &#x3D;&gt; {


            if (self.__isLoaded) {
                self.getPersistenceManager().trigger(self, observer, {
                    name: &#x27;custom&#x27;,
                    data: {
                        name: action
                    }
                });
            } else {
                self.loaded().then((model) &#x3D;&gt; {
                    self.getPersistenceManager().trigger(model, observer, {
                        name: &#x27;custom&#x27;,
                        data: {
                            name: action
                        }
                    });
                });
            }


        });

    }


    /**
     * trigger a webhook url
     * @param {string} url
     * @param {&quot;get&quot; | &quot;post&quot; | &quot;head&quot; | &quot;put&quot; | &quot;patch&quot; | &quot;delete&quot;} method
     * @param {&quot;json&quot; | &quot;html&quot; | &quot;xml&quot;} type
     * @returns {Observable&lt;any&gt;}
     */
    public webhook(url: string, method?: &#x27;get&#x27; | &#x27;post&#x27; | &#x27;head&#x27; | &#x27;put&#x27; | &#x27;patch&#x27; | &#x27;delete&#x27;, type?: &#x27;json&#x27; | &#x27;html&#x27; | &#x27;xml&#x27;) {

        var self &#x3D; this;

        return new Observable&lt;any&gt;((observer: Observer&lt;any&gt;) &#x3D;&gt; {


            if (self.__isLoaded) {
                self.getPersistenceManager().trigger(self, observer, {
                    name: &#x27;webhook&#x27;,
                    data: {
                        url: url,
                        method: method,
                        type: type
                    }
                });
            } else {
                self.loaded().then((model) &#x3D;&gt; {
                    self.getPersistenceManager().trigger(model, observer, {
                        name: &#x27;webhook&#x27;,
                        data: {
                            url: url,
                            method: method,
                            type: type
                        }
                    });
                });
            }


        });

    }


    /**
     * save with optional observable
     * @param action
     * @param silent
     * @returns {Observable&lt;any&gt;}
     */
    public save(action?: actionEmail | actionWebhook | actionGoogleSheets | actionCustom | string, silent?: boolean) {

        let self &#x3D; this, observer &#x3D; null;

        if (typeof action &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
            action &#x3D; {
                name: &#x27;custom&#x27;,
                data: {
                    name: action
                }
            }
        }

        self.executeSave(action).subscribe((next) &#x3D;&gt; {
            if (observer) {
                observer.next(next);
            } else {
                if (!silent) {
                    self.notify(next);
                }
            }
        }, (error) &#x3D;&gt; {
            if (observer) {
                observer.error(error);
            } else {
                if (!silent) {
                    self.notify(error, true);
                }
            }
        }, () &#x3D;&gt; {
            if (observer) {
                observer.complete();
            } else {
                if (!silent) {
                    self.notify(self.getMessage(&#x27;done&#x27;));
                }
            }
        });

        return new Observable&lt;any&gt;((o: Observer&lt;any&gt;) &#x3D;&gt; {
            observer &#x3D; o;
        });


    }


    /**
     * save model and persist if is persistable
     * @param {any} action as an optinal argument for transmitting additional action metadata
     * @returns {Observable&lt;any&gt;}
     */
    private executeSave(action?: actionEmail | actionWebhook | actionGoogleSheets | actionCustom | string) {

        let self &#x3D; this;

        Object.keys(self.__edited).forEach((property) &#x3D;&gt; {
            self[property] &#x3D; self.__edited[property];
        });


        return new Observable&lt;any&gt;((observer: Observer&lt;any&gt;) &#x3D;&gt; {


            self.setHasPendingChanges(true, action);


            if (self.__persistenceManager) {
                self.__persistenceManager.save(self, observer, action).then((success) &#x3D;&gt; {
                    self.__edited &#x3D; {};

                    if (action) {
                        if (self.isOnline()) {
                            observer.next(self.getMessage(&#x27;submitted&#x27;));
                        } else {
                            observer.next(self.getMessage(&#x27;submittedInBackground&#x27;));
                        }
                    } else {
                        observer.complete();
                    }

                }).catch((error) &#x3D;&gt; {
                    self.__edited &#x3D; {};
                    observer.error(error);
                });

            } else {
                observer.error(&#x27;No persistence Manger provided&#x27;);
                self.__edited &#x3D; {};
            }


        });


    }


    /**
     * resets model
     * @returns {PersistableModel}
     */
    public reset() {

        let self &#x3D; this;

        Object.keys(self.getProperties()).forEach((property) &#x3D;&gt; {
            self.update(property, self.transformTypeFromMetadata(property, &#x27;&#x27;));
        });

        self.__edited &#x3D; {};

        return this;


    }

    /**
     * removes edited states
     * @returns {PersistableModel}
     */
    public removeEditedState() {

        this.__edited &#x3D; {};

        return this;


    }

    /**
     * get models observer
     * @returns {Observer&lt;any&gt;}
     */
    public getObserver() {
        return this.__observer;
    }

    /**
     * get models obervable
     * @returns {Observable&lt;any&gt;}
     */
    public getObservable() {
        return this.__observable;
    }

    /**
     * set uuid
     * @param uuid
     * @returns {PersistableModel}
     */
    public setUuid(uuid?) {
        this.__uuid &#x3D; uuid !&#x3D;&#x3D; undefined ? uuid : UUID.UUID();
        return this;
    }

    /**
     * get uuid
     * @returns {string}
     */
    public getUuid() {
        return this.__uuid;
    }

    /**
     * get models constructors name as an object identifier
     * return {string}
     */
    public getObjectIdentifier() {
        return this.constructor.name;
    }

    /**
     * set firebaseDatabase
     * @param {AngularFireDatabase}
     * @returns {PersistableModel}
     */
    public setFirebaseDatabase(firebaseDatabase) {

        this.__firebaseDatabase &#x3D; firebaseDatabase;
        let self &#x3D; this;

        let connectedRef &#x3D; this.__firebaseDatabase.app.database().ref(&quot;.info/connected&quot;);


        connectedRef.on(&quot;value&quot;, (snap) &#x3D;&gt; {
            self.__isOnline &#x3D; snap.val();
            if (self.__persistenceManager &amp;&amp; self.__isOnline) {
                self.__persistenceManager.getObserver().next({&#x27;action&#x27;: &#x27;connected&#x27;});
            }
            if (self.__persistenceManager &amp;&amp; !self.__isOnline) {
                self.__persistenceManager.getObserver().next({&#x27;action&#x27;: &#x27;disconnected&#x27;});
            }

        });

        if (this.getPersistenceManager() !&#x3D;&#x3D; undefined) {

            if (!this.getPersistenceManager()._isConnected) {
                this.getPersistenceManager().getFirebase().getAuth().then((auth: AngularFireAuth) &#x3D;&gt; {
                    auth.authState.subscribe((user) &#x3D;&gt; {
                        if (user &amp;&amp; self.__persistenceManager) {
                            self.__persistenceManager.getObserver().next({&#x27;action&#x27;: &#x27;connected&#x27;});
                        }
                        self.emit();
                    });
                });
                this.getPersistenceManager().setIsConnected();
            }

        }

        return this;

    }


    /**
     * get firebase database
     * @returns {AngularFireDatabase}
     */
    public getFirebaseDatabase() {
        return this.__firebaseDatabase;
    }

    /**
     * set firebase database path
     * @param path
     * @returns {PersistableModel}
     */
    public setFirebaseDatabasePath(path) {
        this.__firebaseDatabasePath &#x3D; path;
        this.registerConditionValidators(false);
        return this;
    }


    /**
     * get firebase database path
     * @returns {string}
     */
    public getFirebaseDatabasePath() {
        return this.__firebaseDatabasePath;
    }

    /**
     * get firebase session data path
     * @param string path
     * @returns string
     */
    public getFirebaseDatabaseSessionPath(path: string) {

        var a &#x3D; path.split(&quot;/&quot;);
        var path &#x3D; &#x27;&#x27;;
        var i &#x3D; 0;
        a.forEach((segment) &#x3D;&gt; {
            if (i &#x3D;&#x3D; 3) {
                path &#x3D; path + &#x27;/data&#x27;;
            }
            path &#x3D; path + &#x27;/&#x27; + segment;
            i++;
        });

       return this.__firebaseDatabaseRoot + &#x27;/&#x27; + this.getFirebaseDatabasePath().substr(this.__firebaseDatabaseRoot.length + 1).split(&quot;/&quot;)[0] + &#x27;/&#x27; + this.getFirebaseDatabasePath().substr(this.__firebaseDatabaseRoot.length + 1).split(&quot;/&quot;)[1] + path.substr(1);

    }


    /**
     * set firebaseDatabaseObject
     * @param firebaseDatabaseObject
     * @returns {PersistableModel}
     */
    public setFirebaseDatabaseObject(firebaseDatabaseObject) {
        this.__angularFireObject &#x3D; firebaseDatabaseObject;
        return this;
    }


    /**
     * get firebaseDatabaseObject
     * @returns {AngularFireObject&lt;any&gt;}
     */
    public getFirebaseDatabaseObject() {
        return this.__angularFireObject;

    }

    /**
     * get firebaseDatabase prefix
     * @returns string
     */
    public getFirebaseDatabaseRoot() {
        return this.__firebaseDatabaseRoot;
    }


    /**
     * set firebase databse path prefix
     * @param path
     * @returns {PersistableModel}
     */
    public setFirebaseDatabaseRoot(path) {

        this.__firebaseDatabaseRoot &#x3D; path;

        return this;

    }

    /**
     * get property
     * @param string property
     * @returns {any}
     */
    public getProperty(property: string) {

        let self &#x3D; this;

        if (this.isInBackendMode()) {
            return self.getPropertyValue(property);
        } else {
            if (!self.__bindings[property]) {

                self.__bindings[property] &#x3D; new Observable&lt;any&gt;((observer: Observer&lt;any&gt;) &#x3D;&gt; {
                    self.__bindingsObserver[property] &#x3D; observer;
                });

                window.setTimeout(() &#x3D;&gt; {
                    if (self.__bindingsObserver[property] !&#x3D;&#x3D; undefined) {
                        self.__bindingsObserver[property].next(self[property]);
                    }
                });

            }

            return self.__bindings[property];
        }


    }


    /**
     * get observer property for using as an binding variable
     * @returns {Observer&lt;any&gt;}
     */
    private getPropertyObserver(property) {


        if (this.__bindingsObserver[property]) {
            return this.__bindingsObserver[property];
        } else {
            return null;
        }


    }

    /**
     * set module provider messages
     * @param {AppsappModuleProviderMessages} messages
     * @returns {PersistableModel}
     */
    private setMessages(messages: AppsappModuleProviderMessages) {

        this.__messages &#x3D; messages;
        return this;

    }

    /**
     * get modules providers message
     * @param keyword
     * @returns {any}
     */
    public getMessage(keyword) {

        if (this.__messages &#x3D;&#x3D;&#x3D; undefined) {
            return keyword;
        }

        return this.__messages[keyword] &#x3D;&#x3D; undefined ? keyword : this.__messages[keyword];

    }

    /**
     * set property value for using as an binding variable
     * @param {string} property
     * @param {any} value
     * @returns {PersistableModel}
     */
    public setProperty(property, value) {

        var self &#x3D; this, autosave &#x3D; false;

        if (this.__isAutosave &amp;&amp; this[property] !&#x3D;&#x3D; value) {
            autosave &#x3D; true;
        }

        self.__editedObservableObservers.forEach((callback: any) &#x3D;&gt; {
            if (callback.property &#x3D;&#x3D; property &amp;&amp; this[property] !&#x3D;&#x3D; value) {
                callback.callback(value);
                callback.first &#x3D; true;
            }
        });

        this[property] &#x3D; value;
        this.__edited[property] &#x3D; value;
        var event &#x3D; {property: property, value: value, model: this};
        if (this.__editedObserver) {
            this.__editedObserver.next(event);
        }
        this.executeConditionValidatorCircular(property);
        this.executeChangesWithCallback(event);

        if (autosave) {
            this.save(null, true);
        }

        return this;
    }


    /**
     * return current property value
     * @param property
     * @param {boolean} get value is in editing mode
     * @returns {any}
     */
    public getPropertyValue(property, editing?) {

        if (editing) {
            return this.__edited[property] ? this.__edited[property] : this[property];
        } else {
            return this[property];
        }

    }

    /**
     * get properties
     * @param stringify
     */
    public getProperties(stringify?) {

        let properties &#x3D; {}, self &#x3D; this;

        Object.keys(self).forEach((property) &#x3D;&gt; {
            if (property.substr(0, 1) !&#x3D;&#x3D; &#x27;_&#x27;) {
                if (stringify) {
                    properties[property] &#x3D; self.__toString(property);
                } else {
                    properties[property] &#x3D; self.getPropertyValue(property);
                }
            }
        });

        return properties;

    }

    /**
     * get properties
     * @param stringify
     */
    public convertListPropertiesFromArrayToObject() {

        let self &#x3D; this;

        Object.keys(self).forEach((property) &#x3D;&gt; {
            if (property.substr(0, 1) !&#x3D;&#x3D; &#x27;_&#x27; &amp;&amp; self.getMetadataValue(property, &#x27;isList&#x27;, null, &#x27;usePropertyAsUuid&#x27;)) {
                let tmp &#x3D; {}, usePropertyAsUuid &#x3D; self.getMetadataValue(property, &#x27;isList&#x27;, null, &#x27;usePropertyAsUuid&#x27;);

                if (usePropertyAsUuid &amp;&amp; usePropertyAsUuid !&#x3D;&#x3D; undefined &amp;&amp; usePropertyAsUuid !&#x3D;&#x3D; true) {
                    self.getPropertyValue(property).forEach((val) &#x3D;&gt; {
                        if (val[usePropertyAsUuid] !&#x3D;&#x3D; undefined) {
                            tmp[val[usePropertyAsUuid]] &#x3D; val;
                        }
                    });
                    self[property] &#x3D; tmp;
                }
            }
        });

        return this;


    }

    /**
     * add a new list entry
     * @param property
     * @param data (json object, persistable model or array of those
     * @param uuid string
     * @returns this
     */
    public add(property, data?: any, uuid?: string) {

        let self &#x3D; this;


        if (this.getMetadataValue(property, &#x27;isList&#x27;)) {

            var toAddModels &#x3D; [];
            var toCreateModels &#x3D; [];

            if (data instanceof this.getMetadataValue(property, &#x27;isList&#x27;)) {
                toAddModels.push(data);
            } else if (typeof data &#x3D;&#x3D; &#x27;object&#x27; &amp;&amp; data.length !&#x3D;&#x3D; undefined) {
                data.forEach((d) &#x3D;&gt; {
                    if (d instanceof this.getMetadataValue(property, &#x27;isList&#x27;)) {
                        toAddModels.push(d);
                    } else {
                        toCreateModels.push(d);
                    }
                });
            } else {
                if (typeof data &#x3D;&#x3D; &#x27;string&#x27;) {
                    var d &#x3D; [];
                    d.push(data);
                    toCreateModels.push(d);
                } else {
                    toCreateModels.push(data);
                }

            }

            toCreateModels.forEach((d) &#x3D;&gt; {

                    if (uuid &#x3D;&#x3D;&#x3D; undefined || uuid &#x3D;&#x3D;&#x3D; null) {
                        uuid &#x3D; d !&#x3D;&#x3D; undefined ? d[self.getMetadataValue(property, &#x27;isList&#x27;, null, &#x27;usePropertyAsUuid&#x27;)] : null;
                    }

                    if (typeof d &#x3D;&#x3D; &#x27;object&#x27; &amp;&amp; d.length &#x3D;&#x3D; 1 &amp;&amp; d[0] !&#x3D;&#x3D; undefined) {
                        d &#x3D; d[0];
                    }

                    var n &#x3D; null;
                    if (self.__appsAppModuleProvider &#x3D;&#x3D;&#x3D; undefined) {

                        // backend mode
                        var constructor &#x3D; self.getMetadataValue(property, &#x27;isList&#x27;);
                        n &#x3D; new constructor();
                        if (uuid !&#x3D;&#x3D; undefined) {
                            n.setUuid(uuid);
                            if (d !&#x3D;&#x3D; undefined) {
                                n.loadJson(d);
                            }
                        }

                    } else {

                        n &#x3D; self.__appsAppModuleProvider.new(self.getMetadataValue(property, &#x27;isList&#x27;), uuid, d);
                        if (self.__isAutosave) {
                            n.autosave();
                        }

                    }

                    toAddModels.push(n);

                    // force conditions to be calculated initially
                    if (!n.isInBackendMode()) {
                        window.setTimeout(() &#x3D;&gt; {

                            Object.keys(n.__conditionActionIfMatchesAction).forEach((property) &#x3D;&gt; {
                                n.getProperty(property).subscribe((value) &#x3D;&gt; {
                                    // skip
                                });
                            });
                            Object.keys(n.__conditionActionIfMatchesRemovedProperties).forEach((property) &#x3D;&gt; {
                                n.getProperty(property).subscribe((value) &#x3D;&gt; {
                                    // skip
                                });

                            });
                        }, 1);
                    }


                }
            );

            var t &#x3D; this.getPropertyValue(property);

            toAddModels.forEach((n) &#x3D;&gt; {
                t.push(n);
            });


            return this.setProperty(property, t);

        } else {
            return this;
        }

    }

    /**
     * remove a new list entry
     * @param property
     * @param uuid string or array set of string
     * @returns this
     */
    public remove(property, uuid?: string | [string]) {


        if (this.getMetadataValue(property, &#x27;isList&#x27;) &amp;&amp; this.__appsAppModuleProvider) {

            var toRemoveUuids &#x3D; {};
            var afterRemovedValue &#x3D; [];

            if (typeof uuid &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
                toRemoveUuids[uuid] &#x3D; true;
            } else {
                uuid.forEach((id) &#x3D;&gt; {
                    toRemoveUuids[id] &#x3D; true;
                })
            }

            this.getPropertyValue(property).forEach((m: any) &#x3D;&gt; {

                if (toRemoveUuids[m.getUuid()] &#x3D;&#x3D;&#x3D; undefined) {
                    afterRemovedValue.push(m);
                }

            });

            this.setProperty(property, afterRemovedValue);


        }

        return this;


    }

    /**
     * return string representative from given property value
     * @param property
     * @param {boolean} get value is in editing mode
     * @returns {any}
     */
    public __toString(property?) {

        if (property &#x3D;&#x3D;&#x3D; undefined) {
            return this.serialize();
        }

        let s &#x3D; null, self &#x3D; this;

        switch (this.getType(property)) {

            case &#x27;text&#x27;:
                s &#x3D; self.getPropertyValue(property);
                break;

            case &#x27;numberplain&#x27;:
                s &#x3D; self.getPropertyValue(property);
                break;

            default:
                if (typeof self.getPropertyValue(property) !&#x3D;&#x3D; &#x27;string&#x27;) {
                    s &#x3D; JSON.stringify(self.getPropertyValue(property));
                } else {
                    s &#x3D; self.getPropertyValue(property);
                }


        }


        return s;

    }

    /**
     * set persistenceManager
     * @param persistenceManager
     * @returns {PersistableModel}
     */
    public setPersistenceManager(persistenceManager) {

        if (persistenceManager !&#x3D;&#x3D; undefined) {
            this.__persistenceManager &#x3D; persistenceManager;
        }


        if (this.__uuid.length &#x3D;&#x3D; 0) {
            this.__uuid &#x3D; UUID.UUID();
        }
        return this;
    }


    /**
     * valid this object
     * @param {boolean} softcheck
     * @returns {Promise&lt;any&gt;}
     */
    public validate(softcheck?) {

        let self &#x3D; this;
        return new Promise(function (resolve, reject) {

            self.removeConditionProperties();


            validate(self, {skipMissingProperties: true}).then(errors &#x3D;&gt; { // errors is an array of validation errors


                if (errors.length &gt; 0) {

                    if (softcheck) {
                        resolve();
                    } else {
                        reject(errors);
                    }

                    self.__validationErrors &#x3D; {};
                    errors.forEach((error) &#x3D;&gt; {
                        self.__validationErrors[error.property] &#x3D; error;
                    });

                } else {
                    resolve();
                    self.__validationErrors &#x3D; {};
                }

                Object.keys(self.__validatorObserver).forEach((property) &#x3D;&gt; {

                    if (self.__validationErrors[property] &#x3D;&#x3D;&#x3D; undefined) {
                        self.__validatorObserver[property].next(false);
                    } else {
                        self.__validatorObserver[property].next(self.__validationErrors[property]);
                    }

                });


            });


        });


    }


    /**
     * remove properties with invalid condition validators
     * @returns {PersistableModel}
     */
    private removeConditionProperties() {

        let self &#x3D; this;

        if (self.__conditionActionIfMatchesRemovedProperties) {
            Object.keys(self.__conditionActionIfMatchesRemovedProperties).forEach((property) &#x3D;&gt; {
                if (self.__conditionActionIfMatchesRemovedProperties[property]) {
                    if (self[property] !&#x3D;&#x3D; undefined) {
                        self.__temp[property] &#x3D; self[property];
                        delete self[property];
                    }
                }
            });
        }

        return this;
    }


    /**
     * get validation observable for given property
     * @param {string} property
     * @return {boolean}
     */
    public getValidation(property) {

        let self &#x3D; this;

        if (self.__validator[property] &#x3D;&#x3D;&#x3D; undefined) {
            self.__validator[property] &#x3D; new Observable&lt;any&gt;((observer: Observer&lt;any&gt;) &#x3D;&gt; {
                self.__validatorObserver[property] &#x3D; observer;
            });
        }

        return self.__validator[property];

    }


    /**
     * get condition observable for given property
     * @param property
     * @returns {Observable}
     */
    public getCondition(property) {

        if (this.__conditionActionIfMatches[property] &#x3D;&#x3D; undefined) {

            if (Object.keys(this.__conditionActionIfMatches).length) {
                this.registerConditionValidators(true);
            }

            if (this.__conditionActionIfMatches[property] &#x3D;&#x3D;&#x3D; undefined) {
                this.__conditionActionIfMatches[property] &#x3D; new Observable&lt;any&gt;((observer: Observer&lt;any&gt;) &#x3D;&gt; {
                    this.__conditionActionIfMatchesObserver[property] &#x3D; observer;
                });

            }

        }

        return this.__conditionActionIfMatches[property];

    }


    /**
     * is the object/property on editing state
     * @param {string} property as an optional argument
     * @returns {boolean}
     */
    public hasChanges(property?) {

        if (property) {

            return !(this.__edited[property] &#x3D;&#x3D;&#x3D; undefined);

        } else {

            return (Object.keys(this.__edited).length)

        }


    }

    /**
     * remove changes state
     * @param {string} property as an optional argument
     * @returns {boolean}
     */
    private setHasNoChanges(property?) {

        if (property) {
            this.__forceUpdateProperty[property] &#x3D; true;

            if (this.__edited[property]) {
                try {
                    delete this.__edited[property];
                } catch (e) {
                    //
                }
            }
        } else {
            this.__edited &#x3D; {};
        }

        return this;


    }

    /**
     * import dynamic properties
     * @param {propertiesAsObject}
     * @returns {Promise&lt;any&gt;}
     */
    public importDynamicProperties(propertiesAsObject) {

        let self &#x3D; this;

        return new Promise(function (resolve, reject) {

            Object.keys(propertiesAsObject).forEach((property) &#x3D;&gt; {
                self[property] &#x3D; self.transformTypeFromMetadata(property, propertiesAsObject[property]);
            });

            resolve(self);

        });


    }


    /**
     * load json data
     * @param {object|string} stringified or real json object
     * @returns {Promise&lt;any&gt;}
     */
    public loadJson(json) {

        let self &#x3D; this;
        json &#x3D; typeof json &#x3D;&#x3D; &#x27;string&#x27; ? JSON.parse(json) : json;

        let model &#x3D; &lt;any&gt;plainToClass(&lt;any&gt;this.constructor, json, {excludePrefixes: [&quot;__&quot;]});


        return new Promise(function (resolve, reject) {

            if (model) {

                let propertiesWithValidationError &#x3D; {};
                model.validate().then((success) &#x3D;&gt; {
                }).catch((error) &#x3D;&gt; {
                    Object.keys(error).forEach((e: any) &#x3D;&gt; {
                        propertiesWithValidationError[e.property] &#x3D; true;
                    });
                });


                // all properties without validation error
                Object.keys(json).forEach((property) &#x3D;&gt; {
                    if (property.substr(0, 2) !&#x3D;&#x3D; &#x27;__&#x27; &amp;&amp; propertiesWithValidationError[property] &#x3D;&#x3D;&#x3D; undefined) {
                        if (Object.keys(self).indexOf(property) &gt;&#x3D; 0) {
                            self.setProperty(property, self.transformTypeFromMetadata(property, model[property]));
                            if (model.isInBackendMode()) {
                                self.__edited[property] &#x3D; self[property];
                            }
                        }
                    }
                });

                resolve(self);

            } else {
                resolve(self);
            }

        });

    }

    /**
     * transform type from metadata to avoid non matching data types
     * @param property
     * @param value
     * @returns {any}
     */
    private transformTypeFromMetadata(property, value) {

        let self &#x3D; this;

        if (this.getMetadata(property, &#x27;isTime&#x27;).length) {
            return typeof value &#x3D;&#x3D; &#x27;string&#x27; ? new Date(value) : (value ? value : new Date());

        }

        if (this.getMetadata(property, &#x27;isDate&#x27;).length) {
            return value ? new Date(value) : (value ? value : new Date());
        }

        if (this.getMetadata(property, &#x27;isCalendar&#x27;).length) {
            return value ? new Date(value) : (value ? value : new Date());
        }

        if (this.getMetadata(property, &#x27;isBirthDate&#x27;).length) {
            return value ? new Date(value) : (value ? value : new Date());
        }

        if (this.getMetadata(property, &#x27;isDateRange&#x27;).length) {
            return typeof value &#x3D;&#x3D; &#x27;object&#x27; ? value : [];
        }


        if (this.getMetadata(property, &#x27;isList&#x27;).length) {


            let valueAsObjects &#x3D; [];

            if (typeof value.forEach !&#x3D;&#x3D; &#x27;function&#x27;) {
                var tmp &#x3D; [];
                Object.keys(value).forEach((v) &#x3D;&gt; {
                    tmp.push(value[v]);
                });
                value &#x3D; tmp;
            }

            if (value.length) {
                value.forEach((itemOriginal) &#x3D;&gt; {
                    if (itemOriginal instanceof PersistableModel &#x3D;&#x3D; false) {
                        let uuid &#x3D; itemOriginal[self.getMetadataValue(property, &#x27;isList&#x27;, null, &#x27;usePropertyAsUuid&#x27;)];
                        let item &#x3D; null;
                        if (self.getAppsAppModuleProvider() !&#x3D;&#x3D; undefined) {
                            item &#x3D; self.getAppsAppModuleProvider().new(self.getMetadataValue(property, &#x27;isList&#x27;), uuid);
                        } else {
                            // backend mode
                            var constructor &#x3D; self.getMetadataValue(property, &#x27;isList&#x27;);
                            item &#x3D; new constructor();
                            if (uuid !&#x3D;&#x3D; undefined) {
                                item.setUuid(uuid);
                            }
                        }

                        if (item !&#x3D;&#x3D; undefined) {
                            item.loadJson(itemOriginal);
                            item.setParent(self);

                            if (!item.isInBackendMode()) {
                                item.loaded().then((m) &#x3D;&gt; {
                                    item.getChangesObserverable().subscribe((next) &#x3D;&gt; {
                                        if (next.model.getParent()) {
                                            next.model.getParent().setProperty(property, self.getPropertyValue(property, true));
                                        }

                                    })
                                });
                            }
                            valueAsObjects.push(item);
                        }

                    } else {
                        valueAsObjects.push(itemOriginal);
                    }
                });
            }

            return valueAsObjects;
        }

        if (this.getMetadata(property, &#x27;isSelect&#x27;).length) {

            let values &#x3D; typeof value &#x3D;&#x3D; &#x27;object&#x27; ? value : [];
            let realValues &#x3D; [];
            if (values.length) {
                values.forEach((val) &#x3D;&gt; {
                    realValues.push(self.getHashedValue(val));
                });
            }
            return realValues;

        }

        return value;

    }

    /**
     * Transform all properties
     * @returns {PersistableModel}
     */
    private transformAllProperties() {

        let self &#x3D; this;

        Object.keys(self).forEach((property) &#x3D;&gt; {
            if (property.substr(0, 1) !&#x3D;&#x3D; &#x27;_&#x27;) {
                self[property] &#x3D; self.transformTypeFromMetadata(property, self[property]);
            }
        });

        return this;

    }

    /**
     * has model pending changes that are not synchronised yet or not
     * @returns {boolean}
     */
    public hasPendingChanges() {

        return this._hasPendingChanges;
    }

    /**
     * set pending changes state
     * @param {boolean} state
     * @param {any} action as an optional argument
     * @returns {PersistableModel}
     */
    public setHasPendingChanges(state, action?: actionEmail | actionWebhook | actionGoogleSheets | actionCustom | string) {

        if (state &amp;&amp; this.__persistenceManager) {
            this.__persistenceManager.addPendingChanges(this, action);
        }

        if (!state &amp;&amp; this.__persistenceManager) {
            this.__persistenceManager.removePendingChanges(this);
        }

        this._hasPendingChanges &#x3D; state;

        return this;
    }

    /**
     * serialize this object
     * @param {boolean} noUnderScoreData
     * @param {boolean} force returning as an real object, otherwise return stringified object
     * @returns {any}
     */
    public serialize(noUnderScoreData?, asObject?) {

        let json &#x3D; &#x27;&#x27;;

        if (noUnderScoreData || noUnderScoreData &#x3D;&#x3D;&#x3D; undefined) {
            json &#x3D; serialize(this, {excludePrefixes: [&quot;__&quot;, &quot;_&quot;]});
        } else {
            json &#x3D; serialize(this, {excludePrefixes: [&quot;__&quot;]});
        }


        if (asObject) {
            return JSON.parse(json);
        } else {
            return json;
        }


    }


    /**
     * get the persistence manger
     * @returns {PersistenceManager}
     */
    public getPersistenceManager() {

        return this.__persistenceManager;

    }

    /**
     * check if current network state is online
     * @returns {boolean}
     */
    public isOnline() {
        return this.__isOnline;

    }

    /**
     * set if model is connected to internet
     * @param state
     */
    public setIsOnline(state) {
        this.__isOnline &#x3D; state;
        return this;
    }

    /**
     * get properties metatadata
     * @param {string} property
     * @param {string} type
     * @returns {Array}
     */
    public getMetadata(property?: string, type?: string) {

        let validationMetadata &#x3D; [];

        this.__metadata.forEach((metadata) &#x3D;&gt; {
            if (!property || metadata.propertyName &#x3D;&#x3D; property) {

                if (!type || metadata.type &#x3D;&#x3D; type || (metadata.type &#x3D;&#x3D; &#x27;customValidation&#x27; &amp;&amp; metadata.constraints &amp;&amp; metadata.constraints[0].type &#x3D;&#x3D; type)) {
                    validationMetadata.push(metadata);
                }

            }
        });

        return validationMetadata;

    }

    /**
     * check if property is type of array
     * @param property
     * @returns {boolean}
     */
    public isArray(property) {

        return typeof this[property] &#x3D;&#x3D; &#x27;object&#x27; ? (this[property] !&#x3D;&#x3D; null &amp;&amp; typeof this[property].length &#x3D;&#x3D; &#x27;number&#x27; ? true : false) : false;

    }


    /**
     * get metadata contraints value
     * @param property
     * @param type
     * @param metadata
     * @param string constraints
     * @returns {any}
     */
    public getMetadataValue(property?, type?, metadataInput?, constraints?) {
        let metadata &#x3D; null;

        if (metadataInput &#x3D;&#x3D; undefined) {
            metadata &#x3D; this.getMetadata(property, type)[0];
        } else {
            if (metadataInput.length) {
                metadataInput.forEach((m) &#x3D;&gt; {
                    if (m.constraints &amp;&amp; m.constraints[0].type &#x3D;&#x3D; type) {
                        metadata &#x3D; m;
                    }
                });
            }
        }

        if (constraints &#x3D;&#x3D; undefined) {
            constraints &#x3D; &#x27;value&#x27;;
        }

        if (metadata &amp;&amp; metadata.constraints) {

            if (metadata.constraints.length &#x3D;&#x3D; 1) {

                if (metadata.constraints[0].type &amp;&amp; Object.keys(metadata.constraints[0]).indexOf(constraints)) {
                    return metadata.constraints[0][constraints] &#x3D;&#x3D; undefined ? true : metadata.constraints[0][constraints];
                }

                return metadata.constraints[0];

            } else {
                return metadata.constraints;
            }

        }

        if (metadata &amp;&amp; metadata.validationTypeOptions) {

            if (metadata.validationTypeOptions.length &#x3D;&#x3D; 1) {
                return metadata.validationTypeOptions[0];
            } else {
                return metadata.validationTypeOptions;
            }

        }


        return null;

    }


    /**
     * resolves input type for given property
     * @param {string} property
     * @returns {any}
     */
    public getType(property) {

        let type &#x3D; null;

        const typeMappings &#x3D; {

            &#x27;isString&#x27;: &#x27;text&#x27;,
            &#x27;isList&#x27;: &#x27;list&#x27;,
            &#x27;number&#x27;: &#x27;numberplain&#x27;,
            &#x27;isPrecision&#x27;: &#x27;numberplain&#x27;,
            &#x27;isNumber&#x27;: &#x27;number&#x27;,
            &#x27;isInt&#x27;: this.getMetadata(property, &#x27;max&#x27;).length &amp;&amp; this.getMetadataValue(property, &#x27;max&#x27;) &lt;&#x3D; 50 ? &#x27;integer&#x27; : &#x27;numberplain&#x27;,
            &#x27;isPhoneNumber&#x27;: &#x27;tel&#x27;,
            &#x27;isPassword&#x27;: &#x27;password&#x27;,
            &#x27;isEmail&#x27;: &#x27;email&#x27;,
            &#x27;isUrl&#x27;: &#x27;url&#x27;,
            &#x27;isText&#x27;: &#x27;textarea&#x27;,
            &#x27;isDate&#x27;: &#x27;date&#x27;,
            &#x27;isDates&#x27;: &#x27;dates&#x27;,
            &#x27;isBoolean&#x27;: &#x27;boolean&#x27;,
            &#x27;isRating&#x27;: &#x27;rating&#x27;,
            &#x27;isBirthDate&#x27;: &#x27;birthday&#x27;,
            &#x27;isSelect&#x27;: &#x27;select&#x27;,
            &#x27;isDateRange&#x27;: &#x27;dates&#x27;,
            &#x27;isCalendar&#x27;: &#x27;date&#x27;,
            &#x27;isTime&#x27;: &#x27;time&#x27;,
            &#x27;isNumpad&#x27;: &#x27;number&#x27;,
            &#x27;customValidation&#x27;: (metadata) &#x3D;&gt; {

                if (metadata.constraints[0].type &amp;&amp; metadata.constraints[0].type &amp;&amp; metadata.constraints[0].type.substr(0, 3) !&#x3D;&#x3D; &#x27;has&#x27;) {
                    return typeMappings[metadata.constraints[0].type] !&#x3D;&#x3D; undefined ? typeMappings[metadata.constraints[0].type] : metadata.constraints[0].type;
                }
                return null;
            }

        }

        this.getMetadata(property).forEach((metadata) &#x3D;&gt; {

            if (type &#x3D;&#x3D; null &amp;&amp; typeMappings[metadata.type] !&#x3D;&#x3D; undefined) {

                if (typeof typeMappings[metadata.type] &#x3D;&#x3D; &#x27;string&#x27;) {
                    type &#x3D; typeMappings[metadata.type];
                } else if (typeof typeMappings[metadata.type] &#x3D;&#x3D; &#x27;function&#x27;) {
                    type &#x3D; typeMappings[metadata.type](metadata);
                }
            }

        });

        if (!type) {
            type &#x3D; typeMappings[typeof this[property]] !&#x3D;&#x3D; undefined ? typeMappings[typeof this[property]] : null;
        }

        return type ? type : &#x27;text&#x27;;


    }


    /**
     * registers condition validators
     * @param {boolean} prepare
     * @returns {PersistableModel}
     */
    private registerConditionValidators(prepare: boolean) {

        let self &#x3D; this;

        self.__conditionBindings &#x3D; {&#x27;request&#x27;: {}, &#x27;properties&#x27;: {}};


        this.getMetadata(null, &#x27;hasConditions&#x27;).forEach((validator) &#x3D;&gt; {

            let hasRealtimeTypes &#x3D; false;


            self.__conditionActionIfMatchesRemovedProperties[validator.propertyName] &#x3D; true;

            if (self.__conditionActionIfMatches[validator.propertyName] &#x3D;&#x3D; undefined) {
                self.__conditionActionIfMatches[validator.propertyName] &#x3D; new Observable&lt;any&gt;((observer: Observer&lt;any&gt;) &#x3D;&gt; {
                    self.__conditionActionIfMatchesObserver[validator.propertyName] &#x3D; observer;
                    self.__conditionActionIfMatchesObserver[validator.propertyName].next({
                        &#x27;action&#x27;: self.__conditionActionIfMatchesAction[validator.propertyName],
                        &#x27;state&#x27;: true
                    });

                });

                // self.__conditionActionIfMatches[validator.propertyName].subscribe(() &#x3D;&gt; {
                // });
                // self.__conditionActionIfMatches[validator.propertyName].share();
                //
            }


            if (!prepare) {


                if (self.__conditionActionIfMatchesObserver &amp;&amp; self.__conditionActionIfMatchesAction[validator.propertyName] &#x3D;&#x3D;&#x3D; undefined &amp;&amp; self.__conditionActionIfMatchesObserver[validator.propertyName]) {
                    self.__conditionActionIfMatchesAction[validator.propertyName] &#x3D; validator.constraints[0].actionIfMatches;
                    self.__conditionActionIfMatchesObserver[validator.propertyName].next({
                        &#x27;action&#x27;: self.__conditionActionIfMatchesAction[validator.propertyName],
                        &#x27;state&#x27;: true
                    });
                }


                validator.constraints[0].value.forEach((v) &#x3D;&gt; {

                    if (v.type &#x3D;&#x3D; &#x27;limit&#x27;) {
                        hasRealtimeTypes &#x3D; true;
                    }

                    if (self.__conditionContraintsProperties[v.property] &#x3D;&#x3D;&#x3D; undefined) {
                        self.__conditionContraintsProperties[v.property] &#x3D; {}
                    }
                    self.__conditionContraintsProperties[v.property][v.type] &#x3D; true;

                    if (self.__conditionContraintsAffectedProperties[v.property] &#x3D;&#x3D;&#x3D; undefined) {
                        self.__conditionContraintsAffectedProperties[v.property] &#x3D; {}
                    }
                    self.__conditionContraintsAffectedProperties[v.property][validator.propertyName] &#x3D; true;


                });

                if (hasRealtimeTypes) {
                    self.__conditionBindings[&#x27;request&#x27;][validator.propertyName] &#x3D; self.getFirebaseDatabase().object(self.getFirebaseDatabasePath() + &quot;/condition/request/&quot; + validator.propertyName);
                    self.__conditionBindings[&#x27;request&#x27;][validator.propertyName].set(validator.constraints[0].value);
                }

            }

        });


        if (!prepare) {
            Object.keys(self.__conditionContraintsProperties).forEach((property) &#x3D;&gt; {
                if (self.__conditionContraintsProperties[property][&#x27;limit&#x27;] !&#x3D;&#x3D; undefined) {
                    self.__conditionBindings[&#x27;properties&#x27;][property] &#x3D; self.getFirebaseDatabase().object(self.getFirebaseDatabasePath() + &quot;/condition/properties/&quot; + property);
                }
            });
        }


        return this;

    }


    private calculateCircularCondition(property: string, chain: object, counter: number) {

        let self &#x3D; this;


        if (self.__conditionContraintsAffectedProperties[property] !&#x3D;&#x3D; undefined) {

            Object.keys(self.__conditionContraintsAffectedProperties[property]).forEach((key) &#x3D;&gt; {

                    if (key &#x3D;&#x3D; property) {
                        return chain;
                    }
                    if (self.__conditionContraintsAffectedProperties[key] !&#x3D;&#x3D; undefined) {

                        chain[key] &#x3D; counter;
                        counter++;
                        self.calculateCircularCondition(key, chain, counter);
                        Object.keys(self.__conditionContraintsAffectedProperties[key]).forEach((k) &#x3D;&gt; {
                            chain[k] &#x3D; counter;

                        });

                    }

                }
            );

        }


        return chain;


    }


    /**
     *
     * @param property
     * @returns {PersistableModel}
     */
    private executeConditionValidatorCircular(property) {

        let self &#x3D; this;

        let circularChain &#x3D; {}, counter &#x3D; 0;
        let obj &#x3D; self.calculateCircularCondition(property, circularChain, counter);
        let keys &#x3D; Object.keys(obj);
        keys.sort(function (a, b) {
            return obj[a] - obj[b]
        });


        self.executeConditionValidator(property);

        keys.forEach((key) &#x3D;&gt; {
            self.executeConditionValidator(key);

        });


        return this;

    }

    /**
     *
     * @param property
     * @returns {PersistableModel}
     */
    private executeConditionValidator(property) {

        let self &#x3D; this;


        if (self.__conditionContraintsProperties[property] !&#x3D;&#x3D; undefined) {
            if (self.__conditionBindings[&#x27;properties&#x27;][property] !&#x3D;&#x3D; undefined) {
                self.__conditionBindings[&#x27;properties&#x27;][property].set(self.__conditionContraintsPropertiesValue[property]);
            }

        }


        let result &#x3D; validateSync(self, {groups: [&quot;condition_&quot; + property]});


        if (result.length) {
            self.__conditionContraintsPropertiesValue[property] &#x3D; null;
        } else {
            self.__conditionContraintsPropertiesValue[property] &#x3D; self.getPropertyValue(property, true);
        }

        if (self.__conditionActionIfMatchesObserver[property] !&#x3D;&#x3D; undefined) {
            self.__conditionActionIfMatchesObserver[property].next({
                action: self.__conditionActionIfMatchesAction[property],
                state: result.length ? true : false
            });
        }

        self.recoverMissingProperty(property);

        self.__conditionActionIfMatchesRemovedProperties[property] &#x3D; result.length ? true : false;
        if (self.__validatorObserver[property]) {
            self.__validatorObserver[property].next(result.length ? true : false);
        }


        if (this.__conditionContraintsAffectedProperties[property] !&#x3D;&#x3D; undefined) {

            Object.keys(this.__conditionContraintsAffectedProperties[property]).forEach((affectedProperty) &#x3D;&gt; {


                let result &#x3D; validateSync(self, {groups: [&quot;condition_&quot; + affectedProperty]});
                if (self.__conditionActionIfMatchesObserver[affectedProperty] !&#x3D;&#x3D; undefined) {

                    self.__conditionActionIfMatchesObserver[affectedProperty].next({
                        action: self.__conditionActionIfMatchesAction[affectedProperty],
                        state: result.length ? true : false
                    });

                }

                self.recoverMissingProperty(affectedProperty);

                self.__conditionActionIfMatchesRemovedProperties[affectedProperty] &#x3D; result.length ? true : false;
                if (self.__validatorObserver[affectedProperty] !&#x3D;&#x3D; undefined) {
                    self.__validatorObserver[affectedProperty].next(result.length ? true : false);
                }

            });

        }

        return this;

    }

    /**
     * recovers a missing property
     * @param property
     * @returns {PersistableModel}
     */
    private recoverMissingProperty(property) {

        if (Object.keys(this).indexOf(property) &#x3D;&#x3D; -1) {
            if (this.__temp[property] &#x3D;&#x3D; undefined) {
                let tmpmodel &#x3D; &lt;any&gt;plainToClass(&lt;any&gt;this.constructor, {}, {excludePrefixes: [&quot;__&quot;]});
                this[property] &#x3D; tmpmodel[property];
            } else {
                this[property] &#x3D; this.__temp[property];
            }
        }

        return this;

    }


    /**
     * set notificationProvider
     * @param notificationProvider
     * @returns {PersistableModel}
     */
    private setNotificationProvider(notificationProvider) {

        this.__notificationProvider &#x3D; notificationProvider;

        return this;
    }


    /**
     *
     * @param promise
     * @returns {PersistableModel}
     */
    private setIsLoadedPromise(promise) {

        let self &#x3D; this;

        this.__isLoadedPromise &#x3D; promise;

        this.__isLoadedPromise.then(() &#x3D;&gt; {
            self.__isLoaded &#x3D; true;
        });


        return this;

    }

    /**
     * Is loaded promise
     * @returns {Promise}
     */
    public loaded() {

        let self &#x3D; this;
        if (this.__isLoadedPromise &#x3D;&#x3D; undefined) {
            return new Promise(function (resolve, reject) {
                resolve(self);
            });
        } else {
            return this.__isLoadedPromise;
        }


    }

    /**
     * send notification message to user
     * @param message
     * @param error
     * @returns {PersistableModel}
     */
    public notify(message, error?) {

        this.__notificationProvider(message, error);

        return this;

    }


    /**
     * Get hased values
     * @Returns object
     */
    public getHashedValues() {

        let values &#x3D; [];
        let self &#x3D; this;

        Object.keys(this.__hashedValues).forEach((hash) &#x3D;&gt; {
            values.push({value: self.__hashedValues[hash], hash: hash});
        });

        return values;

    }

    /**
     * Set hased values
     * @Returns mixed
     */
    public addHashedValue(value, hash) {

        this.__hashedValues[hash] &#x3D; value;
        return this;

    }

    /**
     * Get value from hashed value
     * @param string hash
     * @Returns mixed
     */
    public getHashedValue(hash) {

        return this.__hashedValues[hash] !&#x3D;&#x3D; undefined ? this.__hashedValues[hash] : hash;
    }

    /**
     * Set hashed value
     * @param string value
     * @param hash
     * @Returns string hash
     */
    public setHashedValue(value) {

        let hash &#x3D; typeof value &#x3D;&#x3D; &#x27;object&#x27; ? objectHash.sha1(value) : value;
        this.__hashedValues[hash] &#x3D; value;

        return hash;

    }

    /**
     * set appsAppModuleProvider
     * @param appsAppModuleProvider
     * @returns {this}
     */
    private setAppsAppModuleProvider(appsAppModuleProvider) {

        this.__appsAppModuleProvider &#x3D; appsAppModuleProvider;

        return this;
    }

    /**
     * set appsAppModuleProvider
     * @returns {any}
     */
    public getAppsAppModuleProvider() {
        return this.__appsAppModuleProvider;
    }

    /**
     * set parent model
     * @param parentModel
     * @returns {this}
     */
    public setParent(parentModel) {
        this.__parent &#x3D; parentModel;
        return this;
    }

    /**
     * get parent model
     * @returns {any}
     */
    public getParent() {
        return this.__parent;
    }

    /**
     * get changes observerable
     * @returns {Observable&lt;any&gt;}
     */
    public getChangesObserverable() {
        return this.__editedObservable;
    }

    /**
     * execute changes with callback
     * @param event
     * @returns {this}
     */
    private executeChangesWithCallback(event) {
        this.__editedObservableCallbacks.forEach((callback) &#x3D;&gt; {
            callback(event);
        });

        return this;
    }


    /**
     * observe property
     * @param property
     * @param any callback
     * @returns {this}
     */
    public watch(property, callback) {

        let self &#x3D; this;

        this.__editedObservableObservers.push({callback: callback, property: property});
        callback(this.getPropertyValue(property));

        this.loaded().then((model) &#x3D;&gt; {
            callback(model.getPropertyValue(property));
        });


        return this;

    }


    /**
     * get changes with callback
     * @returns {this}
     */
    public getChangesWithCallback(callback) {
        this.__editedObservableCallbacks.push(callback);
        return this;
    }

    /**
     * Check if model is initialized in backend mode
     * @returns {boolean}
     */
    public isInBackendMode() {
        return global[this.constructor.name] &#x3D;&#x3D;&#x3D; undefined ? false : true;
    }

    /**
     * Enable autosave mode
     * @returns {this}
     */
    public autosave() {
        this.__isAutosave &#x3D; true;
        return this;
    }

    /**
     * check if model has errors or not
     * @returns {boolean}
     */
    public isValid() {
        return Object.keys(this.__validationErrors).length ? false : true;

    }

}
</code></pre>
    </div>
</div>




                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
           </div>
       </div>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script>var COMPODOC_CURRENT_PAGE_DEPTH = 1;</script>

       <script src="../js/search/search.js"></script>
       <script src="../js/search/lunr.min.js"></script>
       <script src="../js/search/search-lunr.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
       <script src="../js/search/search_index.js"></script>

    </body>
</html>
